import asyncio
import numpy as np
import scipy as sk
import pandas as pd
from typing import List, Tuple
import itertools
from ready_trader_one import BaseAutoTrader, Instrument, Lifespan, Side


class AutoTrader(BaseAutoTrader):
    def __init__(self, loop: asyncio.AbstractEventLoop):
        """Initialise a new instance of the AutoTrader class."""
        super(AutoTrader, self).__init__(loop)

        self.order_ids = itertools.count(1)
        self.ask_id = self.ask_price = self.bid_id = self.bid_price = self.position = 0
        print('setting up params')
        self.s0 = 100
        self.T = 1
        self.dt = 0.005
        self.sigma = 2
        self.q0 = 0
        self.gamma = 0.1
        self.k = 1.5
        self.A = 140

    def on_error_message(self, client_order_id: int, error_message: bytes) -> None:
        """Called when the exchange detects an error.

        If the error pertains to a particular order, then the client_order_id
        will identify that order, otherwise the client_order_id will be zero.
        """
        self.logger.warning("error with order %d: %s", client_order_id, error_message.decode())
        self.on_order_status_message(client_order_id, 0, 0, 0)

    def on_order_book_update_message(self, instrument: int, sequence_number: int, ask_prices: List[int],
                                     ask_volumes: List[int], bid_prices: List[int], bid_volumes: List[int]) -> None:
        """Called periodically to report the status of an order book.

        The sequence number can be used to detect missed or out-of-order
        messages. The five best available ask (i.e. sell) and bid (i.e. buy)
        prices are reported along with the volume available at each of those
        price levels.
        """
        #Pricing component - based on optimal HF MM paper by tfushimi et al. 2018
        
        #sym_spread = 0

        #for i in np.arange(0 , self.T, self.dt):
         #   sym_spread += self.gamma * self.sigma**2 * (self.T-i) + (2/self.gamma) * np.log(1+(self.gamma/self.k))
          #  print('sym_spread', sym_spread)
        #av_sym_spread = (sym_spread / (self.T / self.dt))

        #prob = self.A * np.exp(-self.k * av_sym_spread / 2) * self.dt
        #print('prob is', prob)
        
        #Inventory Strategy
        for step, s in enumerate(ask_prices):
            reservation_price = s - self.position * self.gamma * self.sigma**2 * (self.T-step*self.dt)
            spread = self.gamma * self.sigma**2 * (self.T-step*self.dt) + (2/self.gamma) * np.log(1 + (self.gamma/self.k))
            spread /= 2

            if reservation_price >= s:
                ask_spread = spread + (reservation_price - s)
                bid_spread = spread - (reservation_price - s)
            else:
                ask_spread = spread - (s - reservation_price)
                bid_spread = spread + (s - reservation_price)

            ask_prob = self.A * np.exp(-self.k * ask_spread) * self.dt
            bid_prob = self.A * np.exp(-self.k * bid_spread) * self.dt

            ask_prob = max(0, min(ask_prob, 1))
            bid_prob = max(0, min(bid_prob, 1))
            
            if instrument == Instrument.FUTURE:

                best_ask  = s + ask_spread
                best_bid  = s - bid_spread

                #new_ask_price = np.random.choice([1,0], p=[ask_prob, 1 - ask_prob])
                #new_bid_price  = np.random.choice([1,0], p=[bid_prob, 1 - bid_prob])
                
                #print('new ask price', int(best_ask))
                #print('new bid price', int(best_bid))
                print(sequence_number)

                if self.bid_id != 0 and best_bid != self.bid_price and best_bid != 0:
                    self.send_cancel_order(self.bid_id)
                    self.bid_id = 0
                
                if self.ask_id != 0 and best_ask != self.ask_price and best_ask != 0:
                    self.send_cancel_order(self.ask_id)
                    self.ask_id = 0


                if self.bid_id == 0 and best_bid != 0 and self.position < 100:
                    self.bid_id = next(self.order_ids)
                    self.bid_price = best_bid
                    self.send_insert_order(self.bid_id, Side.BUY, int(best_bid), 1, Lifespan.GOOD_FOR_DAY)

                if self.ask_id == 0 and best_ask != 0 and self.position > -100:
                    self.ask_id = next(self.order_ids)
                    self.ask_price = best_ask
                    self.send_insert_order(self.ask_id, Side.SELL, int(best_ask), 1, Lifespan.GOOD_FOR_DAY)



    def on_order_status_message(self, client_order_id: int, fill_volume: int, remaining_volume: int, fees: int) -> None:
        """Called when the status of one of your orders changes.

        The fill_volume is the number of lots already traded, remaining_volume
        is the number of lots yet to be traded and fees is the total fees for
        this order. Remember that you pay fees for being a market taker, but
        you receive fees for being a market maker, so fees can be negative.

        If an order is cancelled its remaining volume will be zero.
        """
        if remaining_volume == 0:
            if client_order_id == self.bid_id:
                self.bid_id = 0
            elif client_order_id == self.ask_id:
                self.ask_id = 0

    def on_position_change_message(self, future_position: int, etf_position: int) -> None:
        """Called when your position changes.

        Since every trade in the ETF is automatically hedged in the future,
        future_position and etf_position will always be the inverse of each
        other (i.e. future_position == -1 * etf_position).
        """
        self.position = etf_position

    def on_trade_ticks_message(self, instrument: int, trade_ticks: List[Tuple[int, int]]) -> None:
        """Called periodically to report trading activity on the market.

        Each trade tick is a pair containing a price and the number of lots
        traded at that price since the last trade ticks message.
        """
        pass
